!>
................................................................................
.                   Copyright (c) 2024.  All Rights Reserved.                  .
................................................................................
.  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.               .
.                                                                              .
.  This code is free software; you can redistribute it and/or modify it under  .
.  the terms of The MIT License (MIT), as published by the Open Source         .
.  Initiative. (See https://opensource.org/license/MIT)                        .
................................................................................
<!

!>
BALI DOCUMENT NOTATION
This document contains a formal definition of the Bali Document Notation™ (Bali)
using Crater Dog Syntax Notation™ (CDSN).

A language grammar consists of a set of rule definitions and token definitions.

The following intrinsic character types are context specific:
 * ANY - Any language specific character.
 * LOWER - Any language specific lowercase character.
 * UPPER - Any language specific uppercase character.
 * DIGIT - Any language specific digit.
 * ESCAPE - Any environment specific escape sequence.
 * CONTROL - Any environment specific (non-printable) control character.
 * EOL - The environment specific end-of-line character.
 * EOF - The environment specific end-of-file marker (pseudo character).

A predicate may be constrained by any of the following cardinalities:
 * predicate{M} - Exactly M instances of the specified predicate.
 * predicate{M..} - M or more instances of the specified predicate.
 * predicate{M..N} - M to N instances of the specified predicate.
 * predicate? - Zero or one instances of the specified predicate.
 * predicate* - Zero or more instances of the specified predicate.
 * predicate+ - One or more instances of the specified predicate.

An inversion "~" within a definition may only be applied to an intrinsic
character type or a glyph range.
<!

!>
RULE DEFINITIONS
The following rules are used by the parser when parsing the stream of tokens
generated by the scanner.  Each rule name begins with an uppercase letter.  The
rule definitions may specify the names of tokens or other rules and are matched
by the parser in the order listed.  A rule definition may also be directly or
indirectly recursive.  The sequence of factors within in a rule definition may
be separated by spaces which are ignored by the parser.
<!
Bali: Document EOL* EOF  ! Terminated with an end-of-file marker.

Document: Header Component

Header: comment EOL+

Component: Entity Context?

Entity:
    Element
    String
    Range
    Collection
    Procedure

Context: "(" Parameters ")"

Parameters:
    Parameter ("," Parameter)*
    (EOL Parameter note?)+ EOL

Parameter: symbol ":" Component

Element:
    angle
    boolean
    duration
    moment
    number
    pattern
    percentage
    probability
    resource

String:
    binary
    bytecode
    name
    narrative
    quote
    symbol
    tag
    version

Range: ("[" | "(") Primitive ".." Primitive ("]" | ")")

Primitive:
    Element
    String

Collection: "[" (Associations | Values) "]"

Associations:
    Association ("," Association)*
    (EOL Association note?)+ EOL
    ":"  ! No associations.

Association: Key ":" Value

Key: Primitive

Values:
    Value ("," Value)*
    (EOL Value note?)+ EOL
    " "  ! No values.

Value: Component

Procedure: "{" Lines "}"

Lines:
    Line (";" Line)*
    (EOL Line note?)+ EOL
    " "  ! No lines.

Line: Annotation? Statement?  ! Allows blank lines.

Annotation: (note | comment) EOL

Statement: MainClause OnClause?

MainClause:
    Flow
    Assignment
    Messaging
    Repository

Flow:
    IfClause
    SelectClause
    WhileClause
    WithClause
    ContinueClause
    BreakClause
    ReturnClause
    ThrowClause

Assignment:
    LetClause

Messaging:
    PostClause
    RetrieveClause
    AcceptClause
    RejectClause
    PublishClause

Repository:
    CheckoutClause
    SaveClause
    DiscardClause
    NotarizeClause

IfClause: "if" Condition "do" Procedure

Condition: Expression

SelectClause: "select" Target ("matching" Template "do" Procedure)+

Target: Expression

Template: Expression

WhileClause: "while" Condition "do" Procedure

WithClause: "with" "each" Item "in" Sequence "do" Procedure

Item: symbol

Sequence: Expression

ContinueClause: "continue" "loop"

BreakClause: "break" "loop"

ReturnClause: "return" Result

Result: Expression

ThrowClause: "throw" Exception

Exception: Expression

LetClause: ("let" Recipient (":=" | "?=" | "+=" | "-=" | "*=" | "/="))? Expression

Recipient:
    symbol
    Attribute

Attribute: Variable "[" Indices "]"

PostClause: "post" Message "to" Bag

Message: Expression

Bag: Expression

RetrieveClause: "retrieve" Recipient "from" Bag

AcceptClause: "accept" Message

RejectClause: "reject" Message

PublishClause: "publish" Event

Event: Expression

CheckoutClause: "checkout" Recipient ("at" "level" Level)? "from" Citation

Level: Expression

Citation: Expression

SaveClause: "save" Draft "as" Citation

Draft: Expression

DiscardClause: "discard" Draft

NotarizeClause: "notarize" Draft "as" Citation

OnClause: "on" Failure ("matching" Template "do" Procedure)+

Failure: symbol

Expression:
    Component
    Intrinsic
    Variable
    Precedence
    Dereference
    Invocation
    Subcomponent
    Chaining
    Exponential
    Inversion
    Arithmetic
    Magnitude
    Comparison
    Complement
    Logical

Intrinsic: Function "(" Arguments? ")"

Function: identifier

Arguments: Argument ("," Argument)*

Argument: Expression

Variable: identifier

Precedence: "(" Expression ")"

Dereference: "@" Expression

Invocation: Target ("." | "<-") Method "(" Arguments? ")"

Method: identifier

Subcomponent: Composite "[" Indices "]"

Composite: Expression

Indices: Index ("," Index)*

Index: Expression

Chaining: Expression "&" Expression

Exponential: Expression "^" Expression

Inversion: ("-" | "/" | "*") Expression

Arithmetic: Expression ("*" | "/" | "//" | "+" | "-") Expression

Magnitude: "|" Expression "|"

Comparison: Expression ("<" | "=" | ">" | "≠" | "IS" | "MATCHES") Expression

Complement: "NOT" Expression

Logical: Expression ("AND" | "SANS" | "OR" | "XOR") Expression

!>
TOKEN DEFINITIONS
The following token definitions are used by the scanner to generate the stream
of tokens that are processed by the parser.  Each token name begins with a
lowercase letter.  Unlike with rule definitions, a token definition cannot
specify the name of a rule within its definition but it can specify the name of
other tokens.  Token definitions cannot be recursive and the scanning of tokens
is NOT greedy.  Any spaces within a token definition are NOT ignored.
<!
angle: '~' (zero | magnitude)

authority: ~['/' CONTROL]+

base10:
    '0'..'9'

base16:
    '0'..'9'
    'a'..'f'

base32:
    '0'..'9'
    'A'..'D'
    'F'..'H'
    'J'..'N'
    'P'..'T'
    'V'..'Z'

base64:
    '0'..'9'
    'A'..'Z'
    'a'..'z'
    '+'
    '/'

binary: "'>" EOL space* base64+ EOL* space* "<'"

boolean:
    "false"
    "true"

bytecode: "'" (instruction (space instruction)*)* "'"

character: ESCAPE | ~['"' CONTROL]

comment: "!>" ANY* "<!"

complex: '(' (rectangular | polar) ')'

day:
    '0'..'2' '1'..'9'
    '3' '0'..'1'

days: timespan 'D'

duration: '~' sign? 'P' (weeks | years? months? days? ('T' hours? minutes? seconds?)?)

e: 'e'

exponent: 'e' sign? ordinal

float: sign? magnitude

fraction: '.' base10+

fragment: ~['>' CONTROL]*

hour:
    '0'..'1' '0'..'9'
    '2' '0'..'3'

hours: timespan 'H'

identifier: letter (letter | DIGIT)*

imaginary: sign? magnitude? 'i'

infinity: sign? ("infinity" | '∞')

instruction: base16{4}

letter:
    LOWER
    UPPER

magnitude:
    e
    pi
    phi
    tau
    scalar

minute: '0'..'5' '0'..'9'

minutes: timespan 'M'

moment: '<' sign? year ('-' month ('-' day ('T' hour (':' minute (':' second fraction?)?)?)?)?)? '>'

month:
    '0' '1'..'9'
    '1' '0'..'2'

months: timespan 'M'

name: ('/' identifier)+

narrative: '"' '>' EOL ANY* EOL space* '<' '"'

note: "! " ~[CONTROL]*

number:
    real
    imaginary
    complex

one: "1."

ordinal: '1'..'9' '0'..'9'*

path: ~['?' '#' '>' CONTROL]*

pattern:
    "none"
    regex
    "any"

percentage: real '%'

phi: "phi" | 'φ'

pi: "pi" | 'π'

polar: magnitude "e^" angle 'i'

probability:
    fraction
    one

query: ~['#' '>' CONTROL]*

quote: '"' character* '"'

real:
    zero
    float
    infinity
    undefined

rectangular: float ", " float 'i'

regex: '"' character+ '"' '?'

resource: '<' scheme ':' ("//" authority)? '/' path ('?' query)? ('#' fragment)? '>'

scalar: (zero fraction | ordinal fraction?) exponent?

scheme: ('a'..'z' | 'A'..'Z') ('0'..'9' | 'a'..'z' | 'A'..'Z' | '+' | '-' | '.')*

second:
    '0'..'5' '0'..'9'
    '6' '0'..'1'

seconds: timespan 'S'

sign: '+' | '-'

space: ' '

symbol: '$' identifier

tag: '#' base32+

tau: "tau" | 'τ'

timespan:
    zero
    ordinal fraction?

undefined: "undefined"

unicode:
    'u' base16{4}
    'U' base16{8}

version: 'v' ordinal ('.' ordinal)*

weeks: timespan 'W'

year:
    zero
    ordinal

years: timespan 'Y'

zero: '0'

